---
title: "Retro-Malware: Writing A Keylogger for DOS, Part 1"
date: 2016-08-30T19:42:06-04:00
draft: false
author: NCommander
tags: [retromalware, dos, assembly, real mode, pc at, soylentnews repost]

---

<p><b>Note: This post originally appeared on <a href="https://soylentnews.org">SoylentNews</a> on <a
            href="https://soylentnews.org/meta/article.pl?sid=16/08/29/1953224">August 30th, 2016</a></b></p>

<p>I've made no secret that I'd like to bring original content to SoylentNews, and <a
        href="https://soylentnews.org/meta/article.pl?sid=16/08/17/001229">recently polled</a> the community on their
    feelings for crowdfunding articles. The overall response was somewhat lukewarm mostly on dividing where money and
    paying authors. As such, taking that into account, I decided to write a series of articles for SN in an attempt to
    drive more subscriptions and readers to the site, and to scratch a personal itch on doing a retro-computing project.
    The question then became: What to write?</p>

<p>As part of a conversation on IRC, part of me wondered what a modern day keylogger would have looked running on DOS.
    In the world of 2016, its no secret that various three letter agencies engage in mass surveillance and cyberwarfare.
    A keylogger would be part of any basic set of attack tools. The question is what would a potential attack tool have
    looked like if it was written during the 1980s. Back in 1980, the world was a very different place both from a
    networking and programming perspective.</p>

<p>For example, in 1988 (the year I was born), the IBM PC/XT and AT would have been a relatively common fixture, and the
    PS/2 only recently released. Most of the personal computing market ran some version of DOS, networking (which was
    rare) frequently took the form of Token Ring or ARCNet equipment. Further up the stack, TCP/IP competed with IPX,
    NetBIOS, and several other protocols for dominance. From the programming side, coding for DOS is very different that
    any modern platform as you had to deal with Intel's segmented architecture, and interacting directly with both the
    BIOS, and hardware. As such its an interesting look at how technology has evolved since.</p>

<p>Now obviously, I don't want to release a ready-made attack tool to be abused for the masses especially since DOS is
    still frequently used in embedded and industry roles. As such, I'm going to target a non-IP based protocol for
    logging both to explore these technologies, while simultaneously making it as useless as possible. To the extent
    possible, I will try and keep everything accessible to non-programmers, but this isn't intended as a tutorial for
    real mode programming. As such I'm not going to go super in-depth in places, but will try to link relevant
    information. If anyone is confused, post a comment, and I'll answer questions or edit these articles as they go
    live.</p>

<p>More past the break ...</p>

<h1>Looking At Our Target</h1>
<p>Back in 1984, IBM released the <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer/AT">Personal
        Computer/AT</a> which can be seen as the common ancestor of all modern PCs. Clone manufacturers copied the basic
    hardware and software interfaces which made the AT, and created the concept of PC-compatible software. Due to the
    sheer proliferation of both the AT and its clones, these interfaces became a de-facto standard which continues to
    this very day. As such, well-written software for the AT can generally be run on modern PCs with a minimum of
    hassle, and it is completely possible to run ancient versions of DOS and OS/2 on modern hardware due to backwards
    compatibility.</p>

<p>A typical business PC of the era likely looked something like this:</p>

<ul>
    <li>An Intel 8086 or 80286 processor running at 4-6 MHz</li>
    <li>256 kilobytes to 1 megabyte of RAM</li>
    <li>5-20 MiB HDD + 5.25 floppy disk drive</li>
    <li>Operating System: DOS 3.x or OS/2 1.x</li>
    <li>Network: Token Ring connected to a NetWare server, or OS/2 LAN Manager</li>
    <li>Cost: ~$6000 USD in 1987</li>
</ul>

<p>To put that in perspective, many of today's microcontrollers have on-par or better specifications than the original
    PC/AT. From a programming perspective, even taking into account resource limitations, coding for the PC/AT is
    drastically different from many modern systems due to the segmented memory model used by the 8086 and 80286. Before
    we dive into the nitty-gritty of a basic 'Hello World' program, we need to take a closer look at the programming
    model and memory architecture used by the 8086 which was a 16-bit processor.</p>

<h1>Real Mode Programming</h1>

<p>If the AT is the common ancestor of all PC-compatibles, then <a href="https://en.wikipedia.org/wiki/Intel_8086">the
        Intel 8086</a> is processor equivalent. The 8086 was a 16-bit processor that operated at a top clock speed of 10
    MHz, had a 20-bit address bus that supported up to 1 megabyte of RAM, and provided fourteen registers. Registers are
    essentially very fast storage locations physically located within the processor that were used to perform various
    operations. Four registers (AX, BX, CX, and DX) are general purpose, meaning they can be used for any operation.
    Eight (described below) are dedicated to working with segments, and the final registers are the processor's current
    instruction pointer (IP), and state (FLAGS)

    An important point in understanding the differences between modern programming environments and those used by early
    PCs deals with the difference between 16-bit and 32/64-bit programming. At the most fundamental level, the number of
    bits a processor has refers to the size of numbers (or integers) it works with internally. As such, the largest
    possible unsigned number a 16-bit processor can directly work with is 2 to the power of 16 (minus 1) or 65,535. As
    the name suggests, 32-bit processors work with larger numbers, with the maximum being 4,294,967,296. Thus, a 16-bit
    processor can only reference up to 64 KiB of memory at a given time while a 32-bit processor can reference up to 4
    GiB, and a 64-bit processor can reference up to 16 exbibytes of memory directly.</p>

<p>At this point, you may be asking yourselves, "if a 16-bit processor could only work with 64 KiB RAM directly, how did
    the the 8086 support up to 1 megabyte?" The answer comes from the segmented memory model. Instead of directly
    referencing a location in RAM, addresses were divided into two 16-bit parts, the selector and offset. Segments are
    64 kilobyte selections of RAM. They could generally be considered the computing equivalent of a postal code, telling
    the processor where to look for data. The offset then told the processor where exactly within that segment the data
    it wanted was located. On the 8086, the selector represented the top 16-bits of an address, and then the offset was
    added to it to create 20-bits (or 1 megabyte) of addressable memory. Segments and offsets are referenced by the
    processor in special registers; in short you had the following:</p>

<ul>
    <li>Segments</li>
    <li>
        <ul>
            <li>CS: Code segment - Application code</li>
            <li>DS: Data segment - Application data</li>
            <li>SS: Stack segment - Stack (or working space) location</li>
            <li>ES: Extra segment - Programmer defined 'spare' segment</li>
        </ul>

    </li>
    <li>Offsets</li>
    <li>
        <ul>
            <li>SI - Source Index</li>
            <li>DI - Destination Index</li>
            <li>BP - Base pointer</li>
            <li>SP - Stack pointer</li>
        </ul>

    </li>
</ul>

<p>As such, memory addresses on the 8086 were written in the form of segment:offset. For example, a given memory address
    of 0x000FFFFF could be written as F000:FFFF. As a consequence, multiple segment:offset pairs could refer to the same
    bit of memory; the addresses F555:AAAF, F000:FFFF, and F800:7FFF all refer to the same bit of memory. The
    segmentation model also had important performance and operational characteristics to consider.</p>

<p>The most important was that since data could be within the same segment, or a different type of segment, you had two
    different types of pointers to work with them. Near pointers (which is just the 16-bit offset) deal with data within
    the same segment, and are very fast as no state information has to be changed to reference them. Far pointers
    pointed to data in a different selector and required multiple operations to work with as you had to not only load
    and store the two 16-bit components, you had to change the segment registers to the correct values. In practice,
    that meant far pointers were extremely costly in terms of execution time. The performance hit was bad enough that it
    eventually lead to one of the greatest (or worst) backward compatibility hacks of all time: <a
        href="https://en.wikipedia.org/wiki/A20_line#A20_gate">the A20 gate</a>, something which I could write a whole
    article on.</p>

<p>The segmented memory model also meant that any high level programming languages had to incorporate lower-level
    programming details into it. For example, while C compilers were available for the 8086 (in the form on Microsoft
    C), the C programming language had to be modified to work with the memory model. This meant that instead of just
    having the standard C pointer types, you had to deal with near and far pointers, and the layout of data and code
    within segments to make the whole thing work. This meant that coding for pre-80386 processors required code
    specifically written for the 8086 and the 80286.</p>

<p>Furthermore, most of the functionality provided by the BIOS and DOS were only available in the form of interrupts.
    Interrupts are special signals used by the process that something needs immediate attention; for examine, typing a
    key on a keyboard generates a IRQ 1 interrupt to let DOS and applications know something happened. Interrupts can be
    generated in software (the 'int' instruction) or hardware. As interrupt handling can generally only be done in raw
    assembly, many DOS apps of the era were written (in whole or in part) in intel assembly. This brings us to our next
    topic: the DOS programming model</p>

<h1>Disassembling 'Hello World'</h1>

<p>Before digging more into the subject, let's look at the traditional 'Hello World' program written for DOS. All code
    posted here is compiled with <a href="http://nasm.us/">NASM</a> </p>

<blockquote>
    <div>
        <p>
        <pre>; Hello.asm - Hello World

section .text
org 0x100

_entry:
 mov ah, 9
 mov dx, str_hello
 int 0x21
 ret

section .data
str_hello: db "Hello World",'$'</pre>
        </p>

    </div>
</blockquote>

<p>Pretty, right? Even for those familiar with 32-bit x86 assembly programming may not be able to understand this at
    first glance what this does. To prevent this from getting too long, I'm going to gloss over the specifics of how DOS
    loads programs, and simply what this does. For non-programmers, this may be confusing, but I'll try an explain it
    below.</p>

<p>The first part of the file has the code segment (marked 'section .text' in NASM) and our program's entry point. With
    COM files such as this, execution begins at the top of file. As such, _entry is where we enter the program. We
    immediately execute two 'mov' instructions to load values into the top half of AX (AH), and a near pointer to our
    string into DX. Ignore 9 for now, we'll get to it in a moment. Afterwords, we trip an interrupt, with the number in
    hex (0x21) after it being the interrupt we want to trip. DOS's functions are exposed as interrupts on 0x20 to 0x2F;
    0x21 is roughly equivalent to stdio in C. 0x21 uses the value in AX to determine which subfunction we want, in this
    case, 9, to write to console. DOS expects a string terminated in $ in DX; it does not use null-terminated strings
    like you may expect. After we return from the interrupt, we simply exit the program by calling ret.</p>

<p>Under DOS, there is no standard library with nicely named functions to help you out of the box (though many compilers
    did ship with these such as Watcom C). Instead, you have to load values into registers, and call the correct
    interrupt to make anything happen. Fortunately, lists of known interrupts are <a
        href="http://www.ctyme.com/rbrown.htm">available</a> to make the process less painful. Furthermore, DOS only
    provides filesystem and network operations. For anything else, you need to talk to the BIOS or hardware directly.
    The best way to think of DOS from a programming perspective is essentially an extension of the basic input/output
    functionality that IBM provided in ROM rather than a full operating system.</p>

<p>We'll dig more into the specifics on future articles, but the takeaway here is that if you want to do anything in
    DOS, interrupts and reference tables are the only way to do so.</p>

<h1>Conclusion</h1>

<p>As an introduction article, we looked at the basics of how 16-bit real mode programming works and the DOS programming
    model. While something of a dry read, it's a necessary foundation to understand the basic building blocks of what is
    to come. In the next article, we'll look more at the DOS API, and terminate-and-stay resident programs, as well as
    hooking interrupts.</p>